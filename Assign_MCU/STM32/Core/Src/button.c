
#include "button.h"

// Định nghĩa các hằng số thời gian dựa trên chu kỳ 10ms
#define LONG_PRESS_TIME_COUNT       100  // 100 * 10ms = 1000ms (1 giây)
#define DOUBLE_PRESS_TIMEOUT_COUNT  30   // 30 * 10ms = 300ms
#define AUTO_INCREASE_TIME_COUNT    50   // 50 * 10ms = 500ms

/* Debounce registers (4 buttons) */
static int KeyReg0[BUTTON_COUNT] = {NOR_STATE, NOR_STATE, NOR_STATE, NOR_STATE};
static int KeyReg1[BUTTON_COUNT] = {NOR_STATE, NOR_STATE, NOR_STATE, NOR_STATE};
static int KeyReg2[BUTTON_COUNT] = {NOR_STATE, NOR_STATE, NOR_STATE, NOR_STATE};
static int KeyReg3[BUTTON_COUNT] = {NOR_STATE, NOR_STATE, NOR_STATE, NOR_STATE};

/* Long press detection */
static int TimeOutForKeyPress[BUTTON_COUNT] = {LONG_PRESS_TIME_COUNT, LONG_PRESS_TIME_COUNT, LONG_PRESS_TIME_COUNT, LONG_PRESS_TIME_COUNT};
static int button_long_pressed[BUTTON_COUNT] = {0, 0, 0, 0};

/* Single press */
static int button_flag[BUTTON_COUNT] = {0, 0, 0, 0};

/* Double press */
int button_double_pressed[BUTTON_COUNT] = {0, 0, 0, 0};
static int press_count[BUTTON_COUNT] = {0, 0, 0, 0};
static int double_press_timeout[BUTTON_COUNT] = {0, 0, 0, 0};

/* Auto-Increase */
int button_auto_increase[BUTTON_COUNT] = {0, 0, 0, 0};
static int auto_increase_counter[BUTTON_COUNT] = {0, 0, 0, 0};
static int button_is_holding[BUTTON_COUNT] = {0, 0, 0, 0};

/* GPIO mapping - adjust if needed, keep as extern in main generated by CubeMX */
static GPIO_TypeDef* BUTTON_PORTS[BUTTON_COUNT] = {
    BUTTON1_GPIO_Port,
    BUTTON2_GPIO_Port,
    BUTTON3_GPIO_Port,
    BUTTON4_GPIO_Port
};

static uint16_t BUTTON_PINS[BUTTON_COUNT] = {
    BUTTON1_Pin,
    BUTTON2_Pin,
    BUTTON3_Pin,
    BUTTON4_Pin
};

/* Initialize button state - call once in main */
void button_init(void){
    for(int i=0;i<BUTTON_COUNT;i++){
        KeyReg0[i] = KeyReg1[i] = KeyReg2[i] = KeyReg3[i] = NOR_STATE;
        TimeOutForKeyPress[i] = LONG_PRESS_TIME_COUNT;
        button_long_pressed[i] = 0;
        button_flag[i] = 0;
        button_double_pressed[i] = 0;
        press_count[i] = 0;
        double_press_timeout[i] = 0;
        button_auto_increase[i] = 0;
        auto_increase_counter[i] = 0;
        button_is_holding[i] = 0;
    }
}

/* Internal helper: subKeyProcess (single/double press logic) */
static void subKeyProcess(int button_index){
    // mark single press now (edge); double press detection via timeout
    button_flag[button_index] = 1;

    if (double_press_timeout[button_index] > 0) {
        press_count[button_index]++;
        if (press_count[button_index] == 2) {
            button_double_pressed[button_index] = 1;
            button_flag[button_index] = 0; // cancel single press
            press_count[button_index] = 0;
            double_press_timeout[button_index] = 0;
        }
    } else {
        press_count[button_index] = 1;
        double_press_timeout[button_index] = DOUBLE_PRESS_TIMEOUT_COUNT;
    }
}

/* The main debounce & detection function - call periodically (10ms) */
void getKeyInput(void){
    for(int i = 0; i < BUTTON_COUNT; i++){

        /* update double press timeout */
        if (double_press_timeout[i] > 0) double_press_timeout[i]--;

        /* shift registers and read GPIO */
        KeyReg2[i] = KeyReg1[i];
        KeyReg1[i] = KeyReg0[i];
        KeyReg0[i] = HAL_GPIO_ReadPin(BUTTON_PORTS[i], BUTTON_PINS[i]);

        /* stable -> compare */
        if ((KeyReg1[i] == KeyReg0[i]) && (KeyReg1[i] == KeyReg2[i])){

            if (KeyReg2[i] != KeyReg3[i]) {
                /* state changed */
                KeyReg3[i] = KeyReg2[i];

                if (KeyReg3[i] == PRESSED_STATE){
                    /* pressed down */
                    TimeOutForKeyPress[i] = LONG_PRESS_TIME_COUNT;
                    subKeyProcess(i);
                    button_is_holding[i] = 0;
                    auto_increase_counter[i] = 0;
                } else {
                    /* released */
                    button_long_pressed[i] = 0;
                    button_is_holding[i] = 0;
                    auto_increase_counter[i] = 0;
                    button_auto_increase[i] = 0;
                }
            } else {
                /* stable and unchanged */
                if (KeyReg3[i] == PRESSED_STATE) {
                    if (button_is_holding[i] == 0) {
                        TimeOutForKeyPress[i]--;
                        if (TimeOutForKeyPress[i] <= 0) {
                            button_long_pressed[i] = 1;
                            button_is_holding[i] = 1;
                            double_press_timeout[i] = 0;
                            press_count[i] = 0;
                            button_flag[i] = 0;
                            auto_increase_counter[i] = AUTO_INCREASE_TIME_COUNT;
                        }
                    } else {
                        /* holding -> auto increase handling */
                        auto_increase_counter[i]--;
                        if (auto_increase_counter[i] <= 0) {
                            auto_increase_counter[i] = AUTO_INCREASE_TIME_COUNT;
                            button_auto_increase[i] = 1;
                        }
                    }
                }
            }
        }
    }
}

/* ----- Getter APIs (edge semantics: clear flag on read) ----- */
int is_button_pressed(int i){
    if(i < 0 || i >= BUTTON_COUNT) return 0;
    if(button_flag[i]){
        button_flag[i] = 0;
        return 1;
    }
    return 0;
}

int is_button_pressed_1s(int i){
    if(i < 0 || i >= BUTTON_COUNT) return 0;
    if(button_long_pressed[i]){
        button_long_pressed[i] = 0;
        return 1;
    }
    return 0;
}

int is_button_double_pressed(int i){
    if(i < 0 || i >= BUTTON_COUNT) return 0;
    if(button_double_pressed[i]){
        button_double_pressed[i] = 0;
        return 1;
    }
    return 0;
}

int is_button_auto_increase(int i){
    if(i < 0 || i >= BUTTON_COUNT) return 0;
    if(button_auto_increase[i]){
        button_auto_increase[i] = 0;
        return 1;
    }
    return 0;
}

int is_button_held(int i){
    if(i < 0 || i >= BUTTON_COUNT) return 0;
    return (KeyReg3[i] == PRESSED_STATE);
}
